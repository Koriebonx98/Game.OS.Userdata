================================================================================
  GAME OS API – COMPLETE REFERENCE & C# GAME LAUNCHER SETUP GUIDE
  (GitHub-Only Edition – no external server required)
================================================================================
Version: 1.0  |  Last updated: 2026

Game OS runs entirely on GitHub's free infrastructure:
  • Frontend  →  GitHub Pages  (static HTML/CSS/JS)
  • Data store →  Private GitHub repository  (one JSON file per user)
  • CI/CD      →  GitHub Actions  (deploy, token injection)
  • "API"      →  GitHub REST API  (https://api.github.com)

There is NO external server, NO monthly hosting bill, and NO infrastructure to
maintain.  Your C# game launcher communicates directly with the GitHub API to
read and write player data — exactly the same way the web frontend does.

────────────────────────────────────────────────────────────────────────────────
TABLE OF CONTENTS
────────────────────────────────────────────────────────────────────────────────
  1.  Architecture overview
  2.  One-time setup (GitHub repositories + PAT)
  3.  How the GitHub-only "API" works
  4.  Data structures (JSON schemas)
  5.  GitHub REST API operations
        5a. Read a file
        5b. Write / update a file
        5c. Delete a file
  6.  Authentication flow for the C# launcher
        6a. Password verification (PBKDF2)
        6b. Storing the session token
  7.  C# integration guide
        7a. NuGet packages
        7b. GameOsClient helper class
        7c. Login
        7d. Read profile, games, achievements
        7e. Add / remove games
        7f. Unlock achievements
        7g. Friends and friend requests
        7h. Online presence (last-seen)
        7i. Log a play session
        7j. Direct messages
        7k. Error handling and rate limits
  8.  Security notes

================================================================================
1.  ARCHITECTURE OVERVIEW
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                          GAME OS – GITHUB-ONLY STACK                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Player's Browser / C# Launcher                                           │
│          │                                                                  │
│          │  HTTPS  (api.github.com)                                        │
│          ▼                                                                  │
│   GitHub REST API ──────────────────────────────────────────────────────── │
│          │                                                                  │
│          ▼                                                                  │
│   Private GitHub Repository  (e.g. YourName/Game.OS.Private.Data)         │
│          │                                                                  │
│          └── accounts/                                                      │
│                ├── email-index.json                                         │
│                ├── alice/                                                   │
│                │     ├── profile.json                                       │
│                │     ├── games.json                                         │
│                │     ├── achievements.json                                  │
│                │     ├── friends.json                                       │
│                │     ├── friend_requests.json                               │
│                │     ├── sent_requests.json                                 │
│                │     ├── presence.json                                      │
│                │     ├── activity.json                                      │
│                │     └── conversations/                                     │
│                │           └── alice_bob.json                               │
│                └── bob/ ...                                                 │
│                                                                             │
│   Frontend  →  GitHub Pages  (your public Game OS website)                 │
│   CI/CD     →  GitHub Actions  (auto-deploys on push to main)              │
└─────────────────────────────────────────────────────────────────────────────┘

No external server. No database. No monthly bill. Everything is GitHub.

================================================================================
2.  ONE-TIME SETUP
================================================================================

Step 1 – Create the private data repository
  1. Go to https://github.com/new
  2. Name it  Game.OS.Private.Data  (or any name you prefer)
  3. Set it to  Private
  4. Click  Create repository

Step 2 – Create a fine-grained Personal Access Token (PAT)
  This token allows the website and C# launcher to read/write the data repo.
  1. Go to  GitHub → Settings → Developer settings →
            Personal access tokens → Fine-grained tokens
  2. Click  Generate new token
  3. Name: Game OS Data Repo
  4. Repository access: Only select repositories → your private data repo
  5. Permissions → Repository permissions → Contents: Read and write
  6. Click  Generate token  and COPY IT — you only see it once!

Step 3 – Add the token as a repository secret (for the web frontend)
  In your Game.OS.Userdata repository (the public frontend repo):
  1. Settings → Secrets and variables → Actions → New repository secret
  2. Name:   DATA_REPO_TOKEN
  3. Value:  the PAT you just copied
  4. Click   Add secret

Step 4 – (Optional) Set the data repo name if it differs from the default
  1. Settings → Secrets and variables → Actions → Variables → New variable
  2. Name: DATA_REPO_NAME   Value: your data repo name

Step 5 – Enable GitHub Pages
  1. Settings → Pages → Source → GitHub Actions

Step 6 – Deploy
  Push any commit to main  (or Actions → Deploy to GitHub Pages → Run workflow).
  The deploy workflow injects the DATA_REPO_TOKEN (XOR-encoded) into script.js
  and publishes the site to GitHub Pages.  ✅

For the C# launcher (Step 2 result): store the PAT securely in the launcher
configuration — it is used to call the GitHub REST API directly (see §6, §7).

================================================================================
3.  HOW THE GITHUB-ONLY "API" WORKS
================================================================================

There are no custom server endpoints.  Every operation is a standard GitHub
REST API call to read or write a JSON file in the private data repository.

Base URL for all data operations:
  https://api.github.com/repos/{OWNER}/{DATA_REPO}/contents/{PATH}

Where:
  {OWNER}     = your GitHub username / org  (e.g. Koriebonx98)
  {DATA_REPO} = private repo name           (e.g. Game.OS.Private.Data)
  {PATH}      = path to a file inside the repo (e.g. accounts/alice/games.json)

Every request requires:
  Authorization: Bearer {PAT}
  Accept: application/vnd.github+json

Rate limits (GitHub API, per authenticated token):
  • Standard fine-grained PAT: 5,000 requests / hour
  • This is far more than enough for a game launcher

================================================================================
4.  DATA STRUCTURES (JSON SCHEMAS)
================================================================================

accounts/email-index.json
  Maps every registered email (lower-cased) to the corresponding username key.
  {
    "alice@example.com": "alice",
    "bob@example.com":   "bob"
  }

accounts/{username_lower}/profile.json
  {
    "username":            "Alice",           // original casing
    "email":               "alice@example.com",
    "password_hash":       "<pbkdf2-hex>",    // 64 hex chars (PBKDF2, see §6a)
    "created_at":          "2026-01-01T00:00:00.000Z",
    "api_token_hash":      "<sha256-hex>",    // optional, present when token issued
    "api_token_issued_at": "2026-02-01T00:00:00.000Z"
  }

accounts/{username_lower}/games.json   (array)
  [
    {
      "platform":  "PC",
      "title":     "Awesome Shooter 2",
      "titleId":   "AS2-PC",          // optional
      "coverUrl":  "https://…",       // optional
      "addedAt":   "2026-01-15T10:00:00.000Z"
    }
  ]

accounts/{username_lower}/achievements.json   (array)
  [
    {
      "platform":      "PC",
      "gameTitle":     "Awesome Shooter 2",
      "achievementId": "headshot_100",
      "name":          "Sharpshooter",
      "description":   "Land 100 headshots",
      "unlockedAt":    "2026-01-20T14:30:00.000Z"
    }
  ]

accounts/{username_lower}/friends.json   (array of lowercase usernames)
  ["bob", "charlie"]

accounts/{username_lower}/friend_requests.json   (incoming requests, array)
  [ { "from": "Dave", "sentAt": "2026-02-01T09:00:00.000Z" } ]

accounts/{username_lower}/sent_requests.json   (outgoing requests, array)
  ["dave"]

accounts/{username_lower}/presence.json
  { "username": "Alice", "lastSeen": "2026-02-20T17:00:00.000Z" }

accounts/{username_lower}/activity.json   (array, newest last, capped at 500)
  [
    {
      "platform":     "PC",
      "gameTitle":    "Awesome Shooter 2",
      "titleId":      "AS2-PC",
      "sessionStart": "2026-02-01T18:00:00.000Z",
      "sessionEnd":   "2026-02-01T19:30:00.000Z",
      "minutesPlayed": 90,
      "loggedAt":     "2026-02-01T19:30:05.000Z"
    }
  ]

accounts/{username_lower}/conversations/{a}_{b}.json   (a < b alphabetically)
  [
    { "from": "Alice", "text": "gg!", "sentAt": "2026-02-01T20:00:00.000Z" }
  ]

================================================================================
5.  GITHUB REST API OPERATIONS
================================================================================

5a.  READ A FILE
─────────────────
  GET https://api.github.com/repos/{OWNER}/{DATA_REPO}/contents/{PATH}
  Authorization: Bearer {PAT}
  Accept: application/vnd.github+json

  Response 200:
    {
      "sha":     "abc123…",
      "content": "<base64 of file content with embedded newlines>",
      "size":    123
    }
  Response 404 → file does not exist yet (treat as empty / not found)

  Decode content:
    C# → string json = Encoding.UTF8.GetString(
                           Convert.FromBase64String(
                               response.content.Replace("\n", "")));

5b.  WRITE / UPDATE A FILE
───────────────────────────
  PUT https://api.github.com/repos/{OWNER}/{DATA_REPO}/contents/{PATH}
  Authorization: Bearer {PAT}
  Accept: application/vnd.github+json
  Content-Type: application/json

  Body:
    {
      "message":   "Add game: Awesome Shooter 2",
      "content":   "<base64 of UTF-8 JSON>",
      "sha":       "<sha from previous GET — omit when creating a new file>",
      "committer": {
        "name":  "Game.OS Launcher",
        "email": "gameos-launcher@users.noreply.github.com"
      }
    }

  Encode content:
    C# → string b64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(json));

  Response 200 (update) or 201 (create):
    { "content": { "sha": "<new sha>", … }, "commit": { … } }

  ⚠ Conflict (HTTP 409 or 422): someone else updated the file at the same time.
    Re-read the file to get the latest SHA, then retry.

5c.  DELETE A FILE
───────────────────
  DELETE https://api.github.com/repos/{OWNER}/{DATA_REPO}/contents/{PATH}
  Authorization: Bearer {PAT}
  Accept: application/vnd.github+json
  Content-Type: application/json

  Body:
    {
      "message":   "Remove file",
      "sha":       "<sha from GET>",
      "committer": {
        "name":  "Game.OS Launcher",
        "email": "gameos-launcher@users.noreply.github.com"
      }
    }

================================================================================
6.  AUTHENTICATION FLOW FOR THE C# LAUNCHER
================================================================================

6a.  PASSWORD VERIFICATION  (PBKDF2)
──────────────────────────────────────
Passwords are never stored in plain text.  The frontend hashes them with PBKDF2
before saving to the data repository.  To verify a password in C#:

  Algorithm : PBKDF2
  Password  : the raw password entered by the player
  Salt      : UTF-8 bytes of  "{username_lower}:gameos"
              e.g. salt for "Alice" → "alice:gameos"
  Iterations: 100,000
  Hash      : SHA-256
  Key length: 32 bytes  (256 bits)

  Expected result: lower-case hex string of the 32-byte derived key
                   (64 hex characters)

  C# example:
  ─────────────────────────────────────────────────────────────────────────
  using System.Security.Cryptography;
  using System.Text;

  static string HashPassword(string password, string username)
  {
      byte[] saltBytes = Encoding.UTF8.GetBytes($"{username.ToLower()}:gameos");
      byte[] passBytes = Encoding.UTF8.GetBytes(password);

      using var pbkdf2 = new Rfc2898DeriveBytes(
          passBytes, saltBytes,
          iterations: 100_000,
          HashAlgorithmName.SHA256);

      byte[] keyBytes = pbkdf2.GetBytes(32);
      return Convert.ToHexString(keyBytes).ToLower();   // .NET 5+
      // .NET 4.x: BitConverter.ToString(keyBytes).Replace("-","").ToLower()
  }

  // Verify:
  string computed = HashPassword(enteredPassword, profile.username);
  bool   valid    = computed == profile.password_hash;
  ─────────────────────────────────────────────────────────────────────────

  ⚠ Bcrypt hashes: If a profile.json shows a password_hash starting with "$2"
    it was created by the optional Node.js backend server (bcrypt).  This only
    occurs when a backend server was run at some point.  Use BCrypt.Net-Next
    to verify these: BCrypt.Verify(password, storedHash).
    Accounts created through the GitHub Pages site always use PBKDF2.

6b.  STORING THE SESSION
──────────────────────────
After a successful login:
  • Store the player's username and the PAT locally in the launcher.
  • Use Windows Credential Manager (CredentialCache / DPAPI) or encrypted
    settings — never store the PAT in a plain text file.
  • The PAT is used in the  Authorization: Bearer  header for all subsequent
    GitHub API calls.
  • When the player logs out, clear the stored PAT.

================================================================================
7.  C# INTEGRATION GUIDE
================================================================================

7a.  NUGET PACKAGES
────────────────────
No third-party packages are required for basic operation.  All APIs used are
part of the .NET standard library.

For bcrypt verification (only needed if your accounts were created by the
optional backend server):
  Install-Package BCrypt.Net-Next

7b.  GAMEOSCLIENT HELPER CLASS
────────────────────────────────
Create GameOsClient.cs in your launcher project and paste the class below.
Fill in the two constants at the top with your real values.

──────────────────────────────────────────────────────────────────────────────
using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;

/// <summary>
/// Game OS client that calls the GitHub REST API to read and write player data.
/// No external server is required — everything runs on GitHub's infrastructure.
/// </summary>
public sealed class GameOsClient : IDisposable
{
    // ── Configuration ─────────────────────────────────────────────────────────
    // Replace these with your real values.
    // OWNER       = your GitHub username / org
    // DATA_REPO   = name of the private data repository
    //
    // PAT SECURITY WARNING: Never commit a real token as a plain string in source
    // code.  Instead, load it at runtime from a secure store:
    //   • Windows Credential Manager (recommended for desktop launchers):
    //       var cred = new NetworkCredential("", secretFromCredManager);
    //       string pat = cred.Password;
    //   • XOR-obfuscation at build time (same technique as the web frontend):
    //       Store the XOR-encoded string as a build constant; decode at runtime
    //       with the same key used to encode it (see §8 for details).
    //   • Environment variable: Environment.GetEnvironmentVariable("GAMEOS_PAT")
    //
    // The placeholder below is intentionally invalid so that accidentally
    // shipping unchanged code does not expose a working credential.
    private const string Owner    = "YourGitHubUsername";
    private const string DataRepo = "Game.OS.Private.Data";

    // ⚠ Replace with a securely loaded token — see comment above.
    private static string GetPat() =>
        Environment.GetEnvironmentVariable("GAMEOS_PAT")
        ?? throw new InvalidOperationException(
            "GAMEOS_PAT environment variable is not set. " +
            "Load the token from a secure source (see Game OS API.txt §8).");

    // ── Internals ─────────────────────────────────────────────────────────────
    private static readonly string BaseUrl =
        $"https://api.github.com/repos/{Owner}/{DataRepo}/contents/";

    private readonly HttpClient _http;
    private string? _username;

    public string? LoggedInUser => _username;

    public GameOsClient()
    {
        _http = new HttpClient();
        _http.DefaultRequestHeaders.Authorization =
            new AuthenticationHeaderValue("Bearer", GetPat());
        _http.DefaultRequestHeaders.Add(
            "Accept", "application/vnd.github+json");
        _http.DefaultRequestHeaders.Add(
            "X-GitHub-Api-Version", "2022-11-28");
        _http.DefaultRequestHeaders.UserAgent.ParseAdd("GameOS-Launcher/1.0");
    }

    // ── §6a: Password hashing ─────────────────────────────────────────────────
    public static string HashPassword(string password, string username)
    {
        byte[] salt = Encoding.UTF8.GetBytes($"{username.ToLower()}:gameos");
        byte[] pass = Encoding.UTF8.GetBytes(password);
        using var pbkdf2 = new Rfc2898DeriveBytes(
            pass, salt, 100_000, HashAlgorithmName.SHA256);
        return Convert.ToHexString(pbkdf2.GetBytes(32)).ToLower();
    }

    // ── Low-level GitHub file helpers ─────────────────────────────────────────
    /// <summary>
    /// Read and deserialise a JSON file from the private data repository.
    /// Returns (content, sha). Returns (default, null) when the file does not exist.
    /// </summary>
    public async Task<(T? content, string? sha)> ReadFileAsync<T>(
        string path, CancellationToken ct = default)
    {
        var resp = await _http.GetAsync(BaseUrl + path, ct);
        if (resp.StatusCode == System.Net.HttpStatusCode.NotFound)
            return (default, null);
        resp.EnsureSuccessStatusCode();

        var ghFile = await resp.Content.ReadFromJsonAsync<GitHubFile>(ct);
        if (ghFile?.Content == null) return (default, null);

        string json = Encoding.UTF8.GetString(
            Convert.FromBase64String(ghFile.Content.Replace("\n", "")));
        var obj = JsonSerializer.Deserialize<T>(json,
            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
        return (obj, ghFile.Sha);
    }

    /// <summary>
    /// Create or update a JSON file in the private data repository.
    /// Pass the sha from a previous ReadFileAsync when updating an existing file.
    /// </summary>
    public async Task<string> WriteFileAsync(
        string path, object content, string message,
        string? sha = null, CancellationToken ct = default)
    {
        string json   = JsonSerializer.Serialize(content,
            new JsonSerializerOptions { WriteIndented = true });
        string b64    = Convert.ToBase64String(Encoding.UTF8.GetBytes(json));

        var body = new Dictionary<string, object?>
        {
            ["message"]   = message,
            ["content"]   = b64,
            ["sha"]       = sha,
            ["committer"] = new { name = "Game.OS Launcher",
                                  email = "gameos-launcher@users.noreply.github.com" }
        };

        var resp = await _http.PutAsJsonAsync(BaseUrl + path, body, ct);
        if (!resp.IsSuccessStatusCode)
        {
            string err = await resp.Content.ReadAsStringAsync(ct);
            throw new GameOsException((int)resp.StatusCode,
                $"Write failed ({(int)resp.StatusCode}): {err}");
        }
        var result = await resp.Content.ReadFromJsonAsync<GitHubWriteResult>(ct);
        return result?.Content?.Sha ?? sha ?? "";
    }

    // ── §7c: Login ────────────────────────────────────────────────────────────
    /// <summary>
    /// Authenticate a player.  Reads their profile from the data repo and
    /// verifies the PBKDF2 password hash.
    /// Returns the UserProfile on success; throws GameOsException on failure.
    /// </summary>
    public async Task<UserProfile> LoginAsync(
        string usernameOrEmail, string password, CancellationToken ct = default)
    {
        string accountKey;
        if (usernameOrEmail.Contains('@'))
        {
            // Resolve email → username via the email index
            var (idx, _) = await ReadFileAsync<Dictionary<string, string>>(
                "accounts/email-index.json", ct);
            if (idx == null || !idx.TryGetValue(
                    usernameOrEmail.ToLower(), out accountKey!))
                throw new GameOsException(401, "Account not found.");
        }
        else
        {
            accountKey = usernameOrEmail.ToLower();
        }

        var (profile, _) = await ReadFileAsync<UserProfile>(
            $"accounts/{accountKey}/profile.json", ct);
        if (profile == null)
            throw new GameOsException(401, "Account not found.");

        // Verify password (PBKDF2 — all accounts created via the website)
        string computed = HashPassword(password, profile.Username);
        if (computed != profile.PasswordHash)
            throw new GameOsException(401, "Invalid password.");

        _username = profile.Username;
        return profile;
    }

    public void Logout() => _username = null;

    // ── §7d: Read profile, games, achievements ────────────────────────────────
    public Task<(UserProfile? p, string? sha)> GetProfileAsync(
        string username, CancellationToken ct = default)
        => ReadFileAsync<UserProfile>(
            $"accounts/{username.ToLower()}/profile.json", ct);

    public Task<(List<Game>? g, string? sha)> GetGamesAsync(
        string username, CancellationToken ct = default)
        => ReadFileAsync<List<Game>>(
            $"accounts/{username.ToLower()}/games.json", ct);

    public Task<(List<Achievement>? a, string? sha)> GetAchievementsAsync(
        string username, CancellationToken ct = default)
        => ReadFileAsync<List<Achievement>>(
            $"accounts/{username.ToLower()}/achievements.json", ct);

    // ── §7e: Add / remove games ───────────────────────────────────────────────
    public async Task AddGameAsync(
        string username, string platform, string title,
        string? titleId = null, string? coverUrl = null,
        CancellationToken ct = default)
    {
        string path = $"accounts/{username.ToLower()}/games.json";
        var (games, sha) = await ReadFileAsync<List<Game>>(path, ct);
        games ??= new List<Game>();

        if (games.Exists(g =>
            g.Platform == platform &&
            string.Equals(g.Title, title, StringComparison.OrdinalIgnoreCase)))
            throw new GameOsException(400, "Game already in library.");

        games.Add(new Game
        {
            Platform = platform, Title = title,
            TitleId  = titleId,  CoverUrl = coverUrl,
            AddedAt  = DateTimeOffset.UtcNow.ToString("o")
        });
        await WriteFileAsync(path, games, $"Add game: {title} ({platform})", sha, ct);
    }

    public async Task RemoveGameAsync(
        string username, string platform, string title,
        CancellationToken ct = default)
    {
        string path = $"accounts/{username.ToLower()}/games.json";
        var (games, sha) = await ReadFileAsync<List<Game>>(path, ct);
        if (games == null) return;

        games.RemoveAll(g =>
            g.Platform == platform &&
            string.Equals(g.Title, title, StringComparison.OrdinalIgnoreCase));

        await WriteFileAsync(path, games, $"Remove game: {title} ({platform})", sha, ct);
    }

    // ── §7f: Unlock achievements ──────────────────────────────────────────────
    public async Task UnlockAchievementAsync(
        string username, string platform, string gameTitle,
        string achievementId, string name, string? description = null,
        DateTimeOffset? unlockedAt = null, CancellationToken ct = default)
    {
        string path = $"accounts/{username.ToLower()}/achievements.json";
        var (list, sha) = await ReadFileAsync<List<Achievement>>(path, ct);
        list ??= new List<Achievement>();

        int idx = list.FindIndex(a =>
            a.Platform == platform &&
            string.Equals(a.GameTitle, gameTitle, StringComparison.OrdinalIgnoreCase) &&
            a.AchievementId == achievementId);

        var entry = new Achievement
        {
            Platform      = platform,
            GameTitle     = gameTitle,
            AchievementId = achievementId,
            Name          = name,
            Description   = description ?? "",
            UnlockedAt    = (unlockedAt ?? DateTimeOffset.UtcNow).ToString("o")
        };

        if (idx >= 0) list[idx] = entry;
        else          list.Add(entry);

        await WriteFileAsync(path, list,
            $"Achievement: {name} in {gameTitle} ({platform})", sha, ct);
    }

    // ── §7g: Friends ──────────────────────────────────────────────────────────
    public Task<(List<string>? f, string? sha)> GetFriendsAsync(
        string username, CancellationToken ct = default)
        => ReadFileAsync<List<string>>(
            $"accounts/{username.ToLower()}/friends.json", ct);

    public async Task SendFriendRequestAsync(
        string fromUsername, string toUsername, CancellationToken ct = default)
    {
        string fromLower = fromUsername.ToLower();
        string toLower   = toUsername.ToLower();
        string sentPath  = $"accounts/{fromLower}/sent_requests.json";
        string theirPath = $"accounts/{toLower}/friend_requests.json";

        // Add to sender's sent list
        var (sent, sentSha) = await ReadFileAsync<List<string>>(sentPath, ct);
        sent ??= new List<string>();
        if (!sent.Contains(toLower)) sent.Add(toLower);
        await WriteFileAsync(sentPath, sent,
            $"Sent friend request to {toUsername}", sentSha, ct);

        // Add to recipient's incoming list
        var (incoming, inSha) = await ReadFileAsync<List<FriendRequest>>(theirPath, ct);
        incoming ??= new List<FriendRequest>();
        incoming.Add(new FriendRequest
        {
            From   = fromUsername,
            SentAt = DateTimeOffset.UtcNow.ToString("o")
        });
        await WriteFileAsync(theirPath, incoming,
            $"Friend request from {fromUsername}", inSha, ct);
    }

    // ── §7h: Online presence ──────────────────────────────────────────────────
    /// <summary>
    /// Update the player's "last seen" timestamp.
    /// Call this every ~60 seconds while the launcher is open.
    /// </summary>
    public async Task UpdatePresenceAsync(
        string username, CancellationToken ct = default)
    {
        string path = $"accounts/{username.ToLower()}/presence.json";
        var (_, sha) = await ReadFileAsync<object>(path, ct);
        var data = new { username, lastSeen = DateTimeOffset.UtcNow.ToString("o") };
        await WriteFileAsync(path, data, $"Presence: {username}", sha, ct);
    }

    /// <summary>
    /// Get the last-seen timestamp for any player.
    /// Online = lastSeen within the last 5 minutes.
    /// </summary>
    public async Task<DateTimeOffset?> GetPresenceAsync(
        string username, CancellationToken ct = default)
    {
        var (pres, _) = await ReadFileAsync<PresenceData>(
            $"accounts/{username.ToLower()}/presence.json", ct);
        if (pres?.LastSeen == null) return null;
        return DateTimeOffset.TryParse(pres.LastSeen, out var dt) ? dt : null;
    }

    // ── §7i: Log a play session ───────────────────────────────────────────────
    public async Task LogActivityAsync(
        string username, string platform, string gameTitle,
        DateTimeOffset sessionStart, int minutesPlayed,
        DateTimeOffset? sessionEnd = null, string? titleId = null,
        CancellationToken ct = default)
    {
        string path = $"accounts/{username.ToLower()}/activity.json";
        var (log, sha) = await ReadFileAsync<List<ActivityEntry>>(path, ct);
        log ??= new List<ActivityEntry>();

        log.Add(new ActivityEntry
        {
            Platform      = platform,
            GameTitle     = gameTitle,
            TitleId       = titleId,
            SessionStart  = sessionStart.ToString("o"),
            SessionEnd    = sessionEnd?.ToString("o"),
            MinutesPlayed = minutesPlayed,
            LoggedAt      = DateTimeOffset.UtcNow.ToString("o")
        });

        // Keep only the last 500 entries
        if (log.Count > 500) log.RemoveRange(0, log.Count - 500);

        await WriteFileAsync(path, log,
            $"Activity: {gameTitle} ({platform}) – {minutesPlayed}min", sha, ct);
    }

    // ── §7j: Direct messages ──────────────────────────────────────────────────
    private static string ConversationPath(string a, string b)
    {
        string la = a.ToLower(), lb = b.ToLower();
        return string.Compare(la, lb, StringComparison.Ordinal) < 0
            ? $"accounts/{la}/conversations/{la}_{lb}.json"
            : $"accounts/{lb}/conversations/{lb}_{la}.json";
    }

    public async Task SendMessageAsync(
        string fromUsername, string toUsername, string text,
        CancellationToken ct = default)
    {
        if (text.Length > 1000)
            throw new GameOsException(400, "Message too long (max 1000 characters).");

        string convPath = ConversationPath(fromUsername, toUsername);
        var (msgs, sha) = await ReadFileAsync<List<Message>>(convPath, ct);
        msgs ??= new List<Message>();
        msgs.Add(new Message
        {
            From   = fromUsername,
            Text   = text,
            SentAt = DateTimeOffset.UtcNow.ToString("o")
        });
        await WriteFileAsync(convPath, msgs,
            $"Message from {fromUsername} to {toUsername}", sha, ct);
    }

    public Task<(List<Message>? msgs, string? sha)> GetMessagesAsync(
        string userA, string userB, CancellationToken ct = default)
        => ReadFileAsync<List<Message>>(ConversationPath(userA, userB), ct);

    public void Dispose() => _http.Dispose();

    // ── GitHub API response wrappers ──────────────────────────────────────────
    private class GitHubFile
    {
        [JsonPropertyName("content")] public string? Content { get; set; }
        [JsonPropertyName("sha")]     public string? Sha     { get; set; }
    }
    private class GitHubWriteResult
    {
        [JsonPropertyName("content")] public GitHubFile? Content { get; set; }
    }
}

// ── Custom exception ───────────────────────────────────────────────────────────
public class GameOsException : Exception
{
    public int StatusCode { get; }
    public GameOsException(int statusCode, string message)
        : base(message) => StatusCode = statusCode;
}

// ── Data model classes ─────────────────────────────────────────────────────────
public class UserProfile
{
    [JsonPropertyName("username")]            public string Username       { get; set; } = "";
    [JsonPropertyName("email")]               public string Email          { get; set; } = "";
    [JsonPropertyName("password_hash")]       public string PasswordHash   { get; set; } = "";
    [JsonPropertyName("created_at")]          public string CreatedAt      { get; set; } = "";
    [JsonPropertyName("api_token_issued_at")] public string? TokenIssuedAt { get; set; }
}

public class Game
{
    [JsonPropertyName("platform")]  public string  Platform { get; set; } = "";
    [JsonPropertyName("title")]     public string  Title    { get; set; } = "";
    [JsonPropertyName("titleId")]   public string? TitleId  { get; set; }
    [JsonPropertyName("coverUrl")]  public string? CoverUrl { get; set; }
    [JsonPropertyName("addedAt")]   public string  AddedAt  { get; set; } = "";
}

public class Achievement
{
    [JsonPropertyName("platform")]      public string Platform      { get; set; } = "";
    [JsonPropertyName("gameTitle")]     public string GameTitle     { get; set; } = "";
    [JsonPropertyName("achievementId")] public string AchievementId { get; set; } = "";
    [JsonPropertyName("name")]          public string Name          { get; set; } = "";
    [JsonPropertyName("description")]   public string Description   { get; set; } = "";
    [JsonPropertyName("unlockedAt")]    public string UnlockedAt    { get; set; } = "";
}

public class FriendRequest
{
    [JsonPropertyName("from")]   public string From   { get; set; } = "";
    [JsonPropertyName("sentAt")] public string SentAt { get; set; } = "";
}

public class PresenceData
{
    [JsonPropertyName("username")] public string? Username { get; set; }
    [JsonPropertyName("lastSeen")] public string? LastSeen { get; set; }
}

public class ActivityEntry
{
    [JsonPropertyName("platform")]      public string  Platform      { get; set; } = "";
    [JsonPropertyName("gameTitle")]     public string  GameTitle     { get; set; } = "";
    [JsonPropertyName("titleId")]       public string? TitleId       { get; set; }
    [JsonPropertyName("sessionStart")]  public string  SessionStart  { get; set; } = "";
    [JsonPropertyName("sessionEnd")]    public string? SessionEnd    { get; set; }
    [JsonPropertyName("minutesPlayed")] public int     MinutesPlayed { get; set; }
    [JsonPropertyName("loggedAt")]      public string  LoggedAt      { get; set; } = "";
}

public class Message
{
    [JsonPropertyName("from")]   public string From   { get; set; } = "";
    [JsonPropertyName("text")]   public string Text   { get; set; } = "";
    [JsonPropertyName("sentAt")] public string SentAt { get; set; } = "";
}
──────────────────────────────────────────────────────────────────────────────

7c.  LOGIN
───────────
using var client = new GameOsClient();

try
{
    var profile = await client.LoginAsync("Alice", "s3curePass");
    Console.WriteLine($"Welcome, {profile.Username}!");

    // Save username for the session — the PAT is already in GameOsClient
    // (see §6b for secure PAT storage in a real launcher)
}
catch (GameOsException ex) when (ex.StatusCode == 401)
{
    Console.WriteLine("Incorrect username or password.");
}

7d.  READ PROFILE, GAMES, ACHIEVEMENTS
────────────────────────────────────────
// Own data
var (profile, _)      = await client.GetProfileAsync("Alice");
var (games, _)        = await client.GetGamesAsync("Alice");
var (achievements, _) = await client.GetAchievementsAsync("Alice");

Console.WriteLine($"Games owned: {games?.Count ?? 0}");

// Any player's data  (same call – PAT grants read access to all accounts)
var (bobGames, _) = await client.GetGamesAsync("Bob");

7e.  ADD / REMOVE GAMES
────────────────────────
// Add a game when the player installs or purchases it
await client.AddGameAsync("Alice", "PC", "Awesome Shooter 2", titleId: "AS2-PC");

// Remove a game
await client.RemoveGameAsync("Alice", "PC", "Awesome Shooter 2");

7f.  UNLOCK ACHIEVEMENTS
─────────────────────────
await client.UnlockAchievementAsync(
    username:      "Alice",
    platform:      "PC",
    gameTitle:     "Awesome Shooter 2",
    achievementId: "headshot_100",
    name:          "Sharpshooter",
    description:   "Land 100 headshots");

7g.  FRIENDS
────────────
var (friends, _) = await client.GetFriendsAsync("Alice");

// Send a friend request
await client.SendFriendRequestAsync(fromUsername: "Alice", toUsername: "Bob");

7h.  ONLINE PRESENCE
─────────────────────
// Keep the player's presence alive while the launcher is open
using var cts = new CancellationTokenSource();
_ = Task.Run(async () =>
{
    while (!cts.Token.IsCancellationRequested)
    {
        await client.UpdatePresenceAsync("Alice");
        await Task.Delay(TimeSpan.FromSeconds(60), cts.Token);
    }
});

// Check if Bob is online (online = last seen < 5 minutes ago)
var lastSeen   = await client.GetPresenceAsync("Bob");
bool bobOnline = lastSeen.HasValue &&
                 (DateTimeOffset.UtcNow - lastSeen.Value).TotalMinutes < 5;

7i.  LOG A PLAY SESSION
────────────────────────
var start = DateTimeOffset.UtcNow.AddHours(-1.5);
await client.LogActivityAsync(
    username:      "Alice",
    platform:      "PC",
    gameTitle:     "Awesome Shooter 2",
    sessionStart:  start,
    minutesPlayed: 90,
    sessionEnd:    DateTimeOffset.UtcNow);

7j.  DIRECT MESSAGES
─────────────────────
// Send a message
await client.SendMessageAsync("Alice", "Bob", "gg!");

// Read the conversation
var (msgs, _) = await client.GetMessagesAsync("Alice", "Bob");

7k.  ERROR HANDLING AND RATE LIMITS
─────────────────────────────────────
try
{
    await client.AddGameAsync("Alice", "PC", "Some Game");
}
catch (GameOsException ex) when (ex.StatusCode == 401)
{
    // PAT is invalid or expired — ask the user to re-generate it
    Console.WriteLine("Session expired. Please generate a new token in Game OS settings.");
}
catch (GameOsException ex) when (ex.StatusCode == 404)
{
    Console.WriteLine("User or file not found.");
}
catch (GameOsException ex) when (ex.StatusCode == 409 || ex.StatusCode == 422)
{
    // Write conflict — another device wrote at the same time; retry after re-reading
    Console.WriteLine("Write conflict — retrying…");
}
catch (GameOsException ex)
{
    Console.WriteLine($"API error {ex.StatusCode}: {ex.Message}");
}
catch (HttpRequestException ex)
{
    Console.WriteLine($"Network error: {ex.Message}");
}

GitHub API rate limit: 5,000 requests/hour per token.
A typical launcher session uses fewer than 50 requests.

================================================================================
8.  SECURITY NOTES
================================================================================

① The PAT grants read and write access to ALL accounts in the data repo.
  Protect it like a password.  Options for embedding it in the C# launcher:
    a) XOR-encode it with a launcher-specific key (same technique used by the
       web frontend's deploy workflow with GameOS_KEY).
    b) Store it encrypted with DPAPI: ProtectedData.Protect(…)
    c) Ship a read-only PAT in the launcher binary (for public profile lookups)
       and require the user to provide their own write-capable PAT at login
       (advanced — more secure, more complex).

② Never commit the raw PAT to source control.  Use the DATA_REPO_TOKEN
  repository secret so only GitHub Actions can read it.

③ The data repository must remain Private.  A public data repo would expose
  all user data (including password hashes) to the internet.

④ Passwords are hashed with PBKDF2 (100,000 iterations, SHA-256, 32 bytes).
  The hash is computed client-side (in the browser or in the C# launcher)
  before it is ever sent to or stored in GitHub.  The raw password never
  leaves the player's device.

⑤ If the PAT is ever compromised:
    1. Go to  GitHub → Settings → Developer settings → Personal access tokens
    2. Revoke the old token
    3. Generate a new fine-grained PAT (§2 Step 2)
    4. Update the DATA_REPO_TOKEN repository secret (§2 Step 3)
    5. Re-run the deploy workflow so the new token is injected into script.js
    6. Update the PAT constant in the C# launcher and re-ship it

⑥ GitHub's rate limit is 5,000 authenticated requests per hour per token.
  This is shared between the website and any C# launchers using the same PAT.
  If you expect heavy traffic, create a separate read-only PAT for the launcher
  so website writes don't compete with launcher reads.

================================================================================
END OF DOCUMENT
================================================================================
